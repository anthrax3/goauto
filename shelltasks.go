// Copyright 2015 Davin Hills. All rights reserved.
// MIT license. License details can be found in the LICENSE file.

package goauto

import (
	"fmt"
	"io"
	"os"
	"os/exec"
	"strings"
)

type shellTask struct {
	cmd       string
	args      []string
	transform Transformer
}

// NewShellTask returns a Tasker which calls out to the shell with the command cmd and arguments arg
// the TaskInfo.Target will be the last argument and is generated by transform(TaskInfo.Src)
// TaskInfo.Target is set to transform(TaskInfo.Src)
func NewShellTask(transform Transformer, cmd string, args ...string) Tasker {
	return shellTask{cmd: cmd, args: args, transform: transform}
}

// Run will execute the task
func (st shellTask) Run(info *TaskInfo) (err error) {
	info.Target = st.transform(info.Src)
	fmt.Fprintln(info.Tout, strings.Title(st.cmd), st.args, info.Target)
	info.Buf.Reset()
	targs := append(st.args, info.Target)
	cmd := exec.Command(st.cmd, targs...)
	cmd.Stdout = &info.Buf
	cmd.Stderr = info.Terr

	defer func() {
		info.Tout.Write(info.Buf.Bytes())
	}()
	err = cmd.Run()
	return
}

// NewCatTask returns a Tasker which writes the file contents to TaskInfo.Buf and TaskInfo.Tout
// after running transform(TaskInfo.Src)
// TaskInfo.Target is set to transform(TaskInfo.Src)
func NewCatTask(t Transformer) Tasker {
	return NewTask(t, cat)
}

func cat(info *TaskInfo) (err error) {
	in, err := os.Open(info.Target)
	if err != nil {
		return
	}
	defer in.Close()
	info.Buf.Reset()
	_, err = info.Buf.ReadFrom(in)
	if err != nil {
		return
	}
	info.Buf.WriteTo(info.Tout)
	return
}

// NewRemoveTask returns a Tasker which will delete the file named transform(TaskInfo.Src)
// TaskInfo.Target is set to transform(TaskInfo.Src)
func NewRemoveTask(t Transformer) Tasker {
	return NewTask(t, remove)
}

func remove(info *TaskInfo) (err error) {
	fmt.Fprintln(info.Tout, "Removing file", info.Target)
	err = os.Remove(info.Target)
	return
}

// NewMoveTask returns a Tasker which will rename a file from TaskInfo.Target to transform(TaskInfo.Src)
// TaskInfo.Target is set to transform(TaskInfo.Src)
func NewMoveTask(t Transformer) Tasker {
	return NewTask(t, move)
}

func move(info *TaskInfo) (err error) {
	fmt.Fprintln(info.Tout, "Renaming file", info.Src, "to", info.Target)
	err = os.Rename(info.Src, info.Target)
	return
}

// NewMkdirTask returns a Tasker which makes a new dir named transform(TaskInfo.Src)
// TaskInfo.Target is not reset
func NewMkdirTask(t Transformer) Tasker {
	return NewTask(t, mkdir)
}

func mkdir(info *TaskInfo) (err error) {
	dir := info.Target
	info.Target = info.Src
	fmt.Fprintln(info.Tout, "Make directory", dir)
	if err = os.Mkdir(dir, 0755); err != nil && !os.IsExist(err) {
		return err
	}
	return nil
}

type copyTask Transformer

// NewCopyTask returns a Tasker that copies the file contents of TaskInfo.Src to transform(TaskInfo.Src)
// TaskInfo.Target is set to transform(TaskInfo.Src)
func NewCopyTask(t Transformer) Tasker {
	return NewTask(t, fcopy)
}

func fcopy(info *TaskInfo) (err error) {
	fmt.Fprintln(info.Tout, "Copy file", info.Src, "to", info.Target)
	in, err := os.Open(info.Src)
	if err != nil {
		return
	}
	defer in.Close()

	out, err := os.Create(info.Target)
	if err != nil {
		return
	}
	defer func() {
		cerr := out.Close()
		if err == nil {
			err = cerr
		}
	}()
	if _, err = io.Copy(out, in); err != nil {
		return
	}

	return out.Sync()
}
