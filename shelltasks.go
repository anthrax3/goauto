// Copyright 2015 Davin Hills. All rights reserved.
// MIT license. License details can be found in the LICENSE file.

package goauto

import (
	"fmt"
	"io"
	"os"
	"os/exec"
	"time"
)

type shellTask struct {
	cmd       string
	args      []string
	transform Transformer
}

// NewShellTask returns a Tasker which calls out to the shell with the command cmd and arguments arg
// the TaskInfo.Target will be the last argument and is equal to TaskInfo.Src
// TaskInfo.Target is set to TaskInfo.Src
func NewShellTask(cmd string, args ...string) Tasker {
	return &shellTask{cmd: cmd, args: args, transform: Identity}
}

// NewShellTaskT returns a Tasker which calls out to the shell with the command cmd and arguments arg
// the TaskInfo.Target will be the last argument and is generated by transform(TaskInfo.Src)
// TaskInfo.Target is set to transform(TaskInfo.Src)
func NewShellTaskT(transform Transformer, cmd string, args ...string) Tasker {
	return &shellTask{cmd: cmd, args: args, transform: transform}
}

// Run will execute the task
func (st *shellTask) Run(info *TaskInfo) (err error) {
	t0 := time.Now()
	info.Target = st.transform(info.Src)
	info.Buf.Reset()
	targs := append(st.args, info.Target)
	cmd := exec.Command(st.cmd, targs...)
	cmd.Stdout = &info.Buf
	cmd.Stderr = info.Terr

	defer func() {
		info.Tout.Write(info.Buf.Bytes())
		if err != nil && info.Verbose {
			t1 := time.Now()
			fmt.Fprintf(info.Tout, ">>> %v %v %v\n", st.cmd, st.args, t1.Sub(t0))
		}
	}()
	err = cmd.Run()
	return
}

// NewCatTask returns a Tasker which writes the file contents to TaskInfo.Buf and TaskInfo.Tout
// after running transform(TaskInfo.Src)
// TaskInfo.Target is set to transform(TaskInfo.Src)
func NewCatTask(t Transformer) Tasker {
	return NewTask(t, cat)
}

func cat(info *TaskInfo) (err error) {
	in, err := os.Open(info.Target)
	if err != nil {
		return
	}
	defer in.Close()
	info.Buf.Reset()
	_, err = info.Buf.ReadFrom(in)
	if err != nil {
		return
	}
	info.Buf.WriteTo(info.Tout)
	if err != nil && info.Verbose {
		fmt.Fprintf(info.Tout, ">>> cat %v", info.Target)
	}
	return
}

// NewRemoveTask returns a Tasker which will delete the file named transform(TaskInfo.Src)
// TaskInfo.Target is set to transform(TaskInfo.Src)
func NewRemoveTask(t Transformer) Tasker {
	return NewTask(t, remove)
}

func remove(info *TaskInfo) (err error) {
	err = os.Remove(info.Target)
	if err != nil && info.Verbose {
		fmt.Fprintf(info.Tout, ">>> Remove %v", info.Target)
	}
	return
}

// NewMoveTask returns a Tasker which will rename a file from TaskInfo.Target to transform(TaskInfo.Src)
// TaskInfo.Target is set to transform(TaskInfo.Src)
func NewMoveTask(t Transformer) Tasker {
	return NewTask(t, move)
}

func move(info *TaskInfo) (err error) {
	err = os.Rename(info.Src, info.Target)
	if err != nil && info.Verbose {
		fmt.Fprintf(info.Tout, ">>> Renaming %v to %v", info.Src, info.Target)
	}
	return
}

// NewMkdirTask returns a Tasker which makes a new dir named transform(TaskInfo.Src)
// TaskInfo.Target is not reset
func NewMkdirTask(t Transformer) Tasker {
	return NewTask(t, mkdir)
}

func mkdir(info *TaskInfo) (err error) {
	dir := info.Target
	info.Target = info.Src
	if err = os.Mkdir(dir, 0755); err != nil && !os.IsExist(err) {
		return
	}
	if err != nil && info.Verbose {
		fmt.Fprintf(info.Tout, ">>> mkdir %v\n", dir)
	}
	return
}

// NewCopyTask returns a Tasker that copies the file contents of TaskInfo.Src to transform(TaskInfo.Src)
// TaskInfo.Target is set to transform(TaskInfo.Src)
func NewCopyTask(t Transformer) Tasker {
	return NewTask(t, fcopy)
}

func fcopy(info *TaskInfo) (err error) {
	in, err := os.Open(info.Src)
	if err != nil {
		return
	}
	defer in.Close()

	out, err := os.Create(info.Target)
	if err != nil {
		return
	}
	defer func() {
		cerr := out.Close()
		if err == nil {
			err = cerr
		}
		if err != nil && info.Verbose {
			fmt.Fprintf(info.Tout, ">>> Copy %v to %v\n", info.Src, info.Target)
		}
	}()
	if _, err = io.Copy(out, in); err != nil {
		return
	}

	return out.Sync()
}
